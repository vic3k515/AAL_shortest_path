#include "../include/BFS.hpp"
#include "../include/Dijkstra.hpp"
#include "../include/A_star.hpp"
#include "../include/draw.hpp"
#include <iostream>
#include <chrono>

using namespace std;
using namespace std::chrono;


//std::array<Raster::Location, 4> Raster::DIRS  {make_pair(1, 0), make_pair(0, -1),
//										 make_pair(-1, 0), make_pair(0, 1)};
/*
void printParent(int **parent, int height, int width) {
	for (int i = 0; i < height; ++i) {
		for (int j = 0; j < width; ++j)
			if (parent[i][j] == INT_MAX)
				std::cout << "M" << " ";
			else if (parent[i][j] >= width*height)
				std::cout << "@" << " ";
			else
				std::cout << parent[i][j] << " ";;
		std::cout << std::endl;
	}
}
*/
void printUsage(char* prog)
{
	cout << "usage: " << prog << " n, where n is a mode number. Modes: "
		<< "1 - raster loaded from stdin, 2 - raster auto-generated with given width, height, "
		<< "number of vertices and edges, 3 - benchmark mode." << endl;
}
/*
void runBFS(Raster* rptr, Raster::Location start, Raster::Location end)
{
	BFS bfs(rptr);
	bfs.shortestPath(start, end);
	vector<Raster::Location> shortest_path_1 = bfs.getPath();
	cout << "Shortest path BFS(inversed): " << endl
		<< "length: " << shortest_path_1.size() << endl;
	drawResult(rptr->getWidth(), rptr->getHeight(), rptr, shortest_path_1);
}*/

void runAlgorithms(Raster* rptr, bool benchmark, vector<int>* bench_info=nullptr)
{
	high_resolution_clock::time_point t1, t2;
	Raster::Location start, end;
	start = rptr->getStart();
	end = rptr->getEnd();
	int width = rptr->getWidth();
	int height = rptr->getHeight();
	BFS bfs(rptr);
	A_star a_star(rptr);
	Dijkstra dijkstra(rptr);

	cout << "Start point: " << start.first << ", " << start.second << endl;
	cout << "End point: " << end.first << ", " << end.second << endl;

	/* BFS */
	//bfs.shortestPath(start, end);
	//vector<Raster::Location> shortest_path_1 = bfs.getPath();
	//cout << "Shortest path BFS(inversed): " << endl
	//	<< "length: " << shortest_path_1.size() << endl;
	//drawResult(width, height, rptr, shortest_path_1);
	if (benchmark && bench_info!=nullptr)
	{
		t1 = high_resolution_clock::now();
		bfs.shortestPath(start, end);
		t2 = high_resolution_clock::now();
		auto duration = duration_cast<microseconds>(t2 - t1).count();
		bench_info->push_back(duration);
		cout << "BFS exec time: " << duration << endl;
	}
	else
		bfs.shortestPath(start, end);
	vector<Raster::Location> shortest_path_1 = bfs.getPath();
	cout << "Shortest path BFS(inversed): " << endl
		<< "length: " << shortest_path_1.size() << endl;
	drawResult(width, height, rptr, shortest_path_1);

	/* Dijkstra*/
	if (benchmark && bench_info != nullptr)
	{
		t1 = high_resolution_clock::now();
		dijkstra.shortestPath(start, end);
		t2 = high_resolution_clock::now();
		auto duration = duration_cast<microseconds>(t2 - t1).count();
		bench_info->push_back(duration);
		cout << "Dijkstra exec time: " << duration << endl;
	}
	else
		dijkstra.shortestPath(start, end);
	vector<Raster::Location> shortest_path_2 = dijkstra.getPath();
	cout << "Shortest path Dijkstra(inversed): " << endl
		<< "length: " << shortest_path_2.size() << endl;
	drawResult(width, height, rptr, shortest_path_2);

	/* A* */
	if (benchmark && bench_info != nullptr)
	{
		t1 = high_resolution_clock::now();
		a_star.shortestPath(start, end);
		t2 = high_resolution_clock::now();
		auto duration = duration_cast<microseconds>(t2 - t1).count();
		bench_info->push_back(duration);
		cout << "A* exec time: " << duration << endl;
	}
	else
		a_star.shortestPath(start, end);
	vector<Raster::Location> shortest_path_3 = a_star.getPath();
	cout << "Shortest path A*(inversed): " << endl
		<< "length: " << shortest_path_3.size() << endl;
	drawResult(width, height, rptr, shortest_path_3);
}

void fromStdinMode()
{
	int width, height;
	pair<int, int> start, end;
	Raster* rptr = nullptr;

	while(cin.good())
	{
		cin >> width >> height;
		rptr = new Raster(width, height);
		if (!(rptr->readGrid()) || !(rptr->readStartAndEnd()))
		{
			delete rptr;
			exit(1);
		}
		runAlgorithms(rptr,false);
		delete rptr;
		rptr = nullptr;
	}
	//make sure memory is deallocated when cin error occurs
	delete rptr;
}

void autoGeneratedMode(bool benchmark, vector<int>* bench_info=nullptr)
{
	int tests, width, height, vertices, edges;
	pair<int, int> start, end;
	Raster* rptr = nullptr;
	cout << "number of tests:" << endl;
	cin >> tests;
	while (tests > 0)
	{
		cout << "raster width:" << endl;
		cin >> width;
		cout << "raster height:" << endl;
		cin >> height;
		cout << "number of vertices:" << endl;
		cin >> vertices;
		cout << "number of edges:" << endl;
		cin >> edges;
		rptr = new Raster(width, height);
		rptr->generateGrid(vertices, edges);
		if (benchmark && bench_info != nullptr)
		{
			bench_info->push_back(vertices);
			bench_info->push_back(edges);
		}
		runAlgorithms(rptr, benchmark, bench_info);

		delete rptr;
		--tests;
	}
}

void benchmarkMode()
{
	vector<int> results;
	autoGeneratedMode(true, &results);

	// print table here
	for (auto i : results)
		cout << i << " ";
}

int main(int argc, char* argv[])
{
	if (argc != 2)
	{
		printUsage(argv[0]);
		exit(1);
	}

	pair<int, int> start, end;
	Raster* rptr = nullptr;

	string mode = argv[1];

	if (mode == "1")
	{
		fromStdinMode();
		return 0;
	}
	else if (mode == "2")
	{
		autoGeneratedMode(false);
		return 0;
	}
	else if (mode == "3")
	{
		benchmarkMode();
		return 0;
	}
	else
	{
		printUsage(argv[0]);
		exit(0);
	}

	//start = rptr->getStart();
	//end = rptr->getEnd();

	////rptr->draw();
	//BFS bfs(rptr);
	//A_star a_star(rptr);
	//Dijkstra dijkstra(rptr);


	//high_resolution_clock::time_point t1, t2;

	//cout << "Start: " << start.first << ", " << start.second << endl;
	//cout << "End: " << end.first << ", " << end.second << endl;

	///* A* */
	//cout << "Shortest path A_star(inversed): " << endl;
	//t1 = high_resolution_clock::now();
	//a_star.shortestPath(start, end);
	//t2 = high_resolution_clock::now();
	//auto duration = duration_cast<microseconds>(t2 - t1).count();
	//cout << "A* exec time: " << duration << endl;

	///* BFS */
	//cout << "Shortest path BFS(inversed): " << endl;
	//t1= high_resolution_clock::now();
	//bfs.shortestPath(start, end);
	//t2 = high_resolution_clock::now();
	//duration = duration_cast<microseconds>(t2 - t1).count();
	//cout << "BFS exec time: " << duration << endl;

	///* Dijkstra*/
	//cout << "Shortest path Dijkstra(inversed): " << endl;
	//t1 = high_resolution_clock::now();
	//dijkstra.shortestPath(start, end);
	//t2 = high_resolution_clock::now();
	//duration = duration_cast<microseconds>(t2 - t1).count();
	//cout << "Dijkstra exec time: " << duration << endl;
	
	delete rptr;
	return 0;
}
