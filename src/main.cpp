/**
 * Finding shortest path between points on square grid.
 *
 * @file main.cpp
 * @brief Main.cpp file for easy testing of path-finding algorihms.
 * @author Wiktor Franus
 */

#include "../include/BFS.hpp"
#include "../include/Dijkstra.hpp"
#include "../include/A_star.hpp"
#include "../include/draw.hpp"
#include <iostream>
#include <chrono>
#include <iomanip>

using namespace std;
using namespace std::chrono;

bool disable_draw = false;

void printUsage(char* prog)
{
	cout << "usage: " << prog << " n <-nd>, where n is a mode number." << endl
		<< "Modes:" << endl
		<< "1 - raster loaded from stdin," << endl
		<< "2 - raster auto-generated with given width, height, "
		<< "number of vertices and edges," << endl
		<< "3 - benchmark mode (mode 2 with exec time measurement)." << endl
		<< "-nd - disables image drawing."<< endl;
}

/**
 * Runs all 3 algorithms to find shortest path on raster pointed by rptr.
 * If benchark is true, execution time are measured and stored in vector
 * pointed by bench_info. If disable_draw is false, image of raster with
 * marked shortest path is drawn for each algorithm.
 */
void runAlgorithms(Raster* rptr, bool benchmark, vector<int>* bench_info=nullptr)
{
	high_resolution_clock::time_point t1, t2;
	Raster::Location start = rptr->getStart();
	Raster::Location end = rptr->getEnd();
	int width = rptr->getWidth();
	int height = rptr->getHeight();
	BFS bfs(rptr);
	A_star a_star(rptr);
	Dijkstra dijkstra(rptr);

	if(!benchmark)
	{
		cout << "Start point: " << start.first << ", " << start.second << endl;
		cout << "End point: " << end.first << ", " << end.second << endl;
	}

	/* BFS */
	if (benchmark && bench_info!=nullptr)
	{
		t1 = high_resolution_clock::now();
		bfs.shortestPath(start, end);
		t2 = high_resolution_clock::now();
		auto duration = duration_cast<microseconds>(t2 - t1).count();
		bench_info->push_back(duration);
	}
	else
		bfs.shortestPath(start, end);
	vector<Raster::Location> shortest_path_1 = bfs.getPath();
	if(!benchmark)
		cout << "Shortest path BFS: " << endl
			<< "length: " << shortest_path_1.size() << endl;
	if(!disable_draw)
		drawResult(width, height, rptr, shortest_path_1);

	/* Dijkstra*/
	if (benchmark && bench_info != nullptr)
	{
		t1 = high_resolution_clock::now();
		dijkstra.shortestPath(start, end);
		t2 = high_resolution_clock::now();
		auto duration = duration_cast<microseconds>(t2 - t1).count();
		bench_info->push_back(duration);
	}
	else
		dijkstra.shortestPath(start, end);
	vector<Raster::Location> shortest_path_2 = dijkstra.getPath();
	if(!benchmark)
		cout << "Shortest path Dijkstra: " << endl
			<< "length: " << shortest_path_2.size() << endl;
	if(!disable_draw)
		drawResult(width, height, rptr, shortest_path_2);

	/* A* */
	if (benchmark && bench_info != nullptr)
	{
		t1 = high_resolution_clock::now();
		a_star.shortestPath(start, end);
		t2 = high_resolution_clock::now();
		auto duration = duration_cast<microseconds>(t2 - t1).count();
		bench_info->push_back(duration);
	}
	else
		a_star.shortestPath(start, end);
	vector<Raster::Location> shortest_path_3 = a_star.getPath();
	if(!benchmark)
		cout << "Shortest path A*: " << endl
			<< "length: " << shortest_path_3.size() << endl;
	if(!disable_draw)
		drawResult(width, height, rptr, shortest_path_3);
}

/**
 * Runs all 3 algorithms on raster loaded from stdin. User has to
 * provide raster data leaded by width and height of the raster and
 * followed by coordinates of start and end point.
 */
void fromStdinMode()
{
	int width, height;
	pair<int, int> start, end;
	Raster* rptr = nullptr;

	while(cin.good())
	{
		cin >> width >> height;
		rptr = new Raster(width, height);
		if (!(rptr->readGrid()) || !(rptr->readStartAndEnd()))
		{
			delete rptr;
			exit(1);
		}
		runAlgorithms(rptr,false);
		delete rptr;
		rptr = nullptr;
	}
	//make sure memory is deallocated when cin error occurs
	delete rptr;
}

/**
 * Runs all 3 algorithms given number of times on auto-generated raster.
 * User is supposed to provide number of tests and width, height, number
 * of vertices and edges for each test (raster).
 * Generated grid will contain exacly given number of vertices OR
 * exacly given number of edges.
 * Parameter benchark set to true enables benchmark feautures.
 */
void autoGeneratedMode(bool benchmark, vector<int>* bench_info=nullptr)
{
	int tests, width, height, vertices, edges;
	pair<int, int> start, end;
	Raster* rptr = nullptr;
	if(!benchmark)
		cout << "number of tests:" << endl;
	cin >> tests;
	while (tests > 0)
	{
		if(!benchmark)
			cout << "raster width:" << endl;
		cin >> width;
		if(!benchmark)
			cout << "raster height:" << endl;
		cin >> height;
		if(!benchmark)
			cout << "number of vertices:" << endl;
		cin >> vertices;
		if(!benchmark)
			cout << "number of edges:" << endl;
		cin >> edges;
		rptr = new Raster(width, height);
		rptr->generateGrid(vertices, edges);
		if (benchmark && bench_info != nullptr)
		{
			bench_info->push_back(vertices);
			bench_info->push_back(edges);
		}
		runAlgorithms(rptr, benchmark, bench_info);

		delete rptr;
		--tests;
	}
}

/**
 * Runs autoGeneratedMode with benchmark on. Prints benchmark
 * info as table for each algorithm. Table contains number of
 * vertices and edges, times of execution and q parameter for
 * each test.
 *
 * q = (t(n) * T(n_median) / (T(n) * t(n_median)) = (t(n) * constant) / T(n)
 * t(n) is exec time for given number of vertices and edges
 * T(n) is theoretical time complexity for given number of vertices and edges
 * n_median is number of edges and vertices taken from middle test.
 */
void benchmarkMode()
{
	vector<int> results, edges, vertices,
		bfs_times, dijkstra_times, a_star_times;
	vector<double> bfs_q, dijkstra_q, a_star_q;

	autoGeneratedMode(true, &results);

	char fill = ' ';
	int width = 10;
	int v, e, median, time_bfs, time_dijkstra, time_a_star, q,
		t_med, q_med, v_med, e_med, T;
	double T_med;

	// organize benchmark results into buckets
	for (auto it = results.begin(); it != results.end(); ++it)
	{
		vertices.push_back(*it++);
		edges.push_back(*it++);
		bfs_times.push_back(*it++);
		dijkstra_times.push_back(*it++);
		a_star_times.push_back(*it);
	}
	int no_test = vertices.size();
	bfs_q.resize(no_test);
	dijkstra_q.resize(no_test);
	a_star_q.resize(no_test);

	// find median index
	if (no_test % 2 == 0)
		median = (no_test / 2) - 1;
	else
		median = no_test / 2;

	v_med = vertices[median];
	e_med = edges[median];

	// BFS - O(V+E)
	T_med = v_med + e_med;
	t_med = bfs_times[median];
	double constant = T_med / (double)t_med;
	bfs_q[median] = 1.0;
	for (int i = 0; i < no_test; ++i)
	{
		if (i == median) continue;
		T = vertices[i] + edges[i];
		bfs_q[i] = (bfs_times[i] * constant) / T;
	}

	// Dijkstra - O(E*logV)
	T_med = (double)e_med * log((double)v_med);
	t_med = dijkstra_times[median];
	constant = T_med / (double)t_med;
	dijkstra_q[median] = 1.0;
	for (int i = 0; i < no_test; ++i)
	{
		if (i == median) continue;
		T = edges[i] * log((double)vertices[i]);
		dijkstra_q[i] = (dijkstra_times[i] * constant) / T;
	}

	// A* - O(E)
	T_med = e_med;
	t_med = a_star_times[median];
	constant = T_med / (double)t_med;
	a_star_q[median] = 1.0;
	for (int i = 0; i < no_test; ++i)
	{
		if (i == median) continue;
		T = edges[i];
		a_star_q[i] = (a_star_times[i] * constant) / T;
	}

	vector<string> alg_names = { "BFS O(V+E)" , "Dijkstra O(E*logV)" , "A* O(E)" };

	for (int k = 0; k < 3; ++k)
	{
		cout << endl << alg_names[k] << endl;
		cout << left << setw(width) << setfill(fill) << "V";
		cout << left  << setw(width) << setfill(fill) << "E";
		cout << left  << setw(width) << setfill(fill) << "t(n)[ms]";
		cout << left  << setw(width) << setfill(fill) << "q(n)" << endl;
		for (int i = 0; i < no_test; ++i)
		{
			cout << std::left << setw(width) << setfill(fill) << vertices[i];
			cout << std::left << setw(width) << setfill(fill) << edges[i];
			if(k==0)
				cout << std::left << setw(width) << setfill(fill) << bfs_times[i];
			else if(k==1)
				cout << std::left << setw(width) << setfill(fill) << dijkstra_times[i];
			else
				cout << std::left << setw(width) << setfill(fill) << a_star_times[i];
			if(k==0)
				cout << std::left << std::fixed << setw(width) << setfill(fill) << bfs_q[i] << endl;
			else if(k==1)
				cout << std::left << std::fixed << setw(width) << setfill(fill) << dijkstra_q[i] << endl;
			else
				cout << std::left << std::fixed << setw(width) << setfill(fill) << a_star_q[i] << endl;
		}
	}
}

int main(int argc, char* argv[])
{
	if (argc < 2 || argc > 3)
	{
		printUsage(argv[0]);
		exit(1);
	}

	pair<int, int> start, end;
	Raster* rptr = nullptr;

	string mode = argv[1];
	string nd = "";

	if(argc == 3)
		nd = argv[2];
	if(nd == "-nd")
		disable_draw = true; // sets global flag

	try
	{
		if (mode == "1")
		{
			fromStdinMode();
			return 0;
		}
		else if (mode == "2")
		{
			autoGeneratedMode(false);
			return 0;
		}
		else if (mode == "3")
		{
			benchmarkMode();
			return 0;
		}
		else
		{
			printUsage(argv[0]);
			exit(0);
		}
	}
	catch(exception& e)
	{
		cout << "Exception: " << e.what() << endl;
	}

	delete rptr;
	return 0;
}
